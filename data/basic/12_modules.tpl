<ion-view view-title="12 - Modules">
<ion-content style="margin:0 12px">
<div class="col-md-7 middle-col">
<h1>Modules and Mixins</h1>
<hr>
<p>Modules are a way of grouping together methods, classes, and constants. Modules give you two major benefits.</p>
<ion-list>
<li><p>Modules provide a <i>namespace</i> and prevent name clashes.</p></li>
<li><p>Modules implement the <i>mixin</i> facility.</p></li>
</ion-list>
<p>Modules define a namespace, a sandbox in which your methods and constants can play without having to worry about being stepped on by other methods and constants.</p>
<h2>Syntax:</h2>
<pre class="prettyprint notranslate prettyprinted"><span class="kwd">module</span><span class="pln"> </span><span class="typ">Identifier</span><span class="pln">
   statement1
   statement2
   </span><span class="pun">...........</span><span class="pln">
</span><span class="kwd">end</span></pre>
<p>Module constants are named just like class constants, with an initial uppercase letter. The method definitions look similar, too: Module methods are defined just like class methods.</p>
<p>As with class methods, you call a module method by preceding its name with the module's name and a period, and you reference a constant using the module name and two colons.</p>
<h2>Example:</h2>
<pre class="prettyprint notranslate prettyprinted"><span class="com">#!/usr/bin/ruby</span><span class="pln">

</span><span class="com"># Module defined in trig.rb file</span><span class="pln">

</span><span class="kwd">module</span><span class="pln"> </span><span class="typ">Trig</span><span class="pln">
   PI </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3.141592654</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> </span><span class="typ">Trig</span><span class="pun">.</span><span class="pln">sin</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln">
   </span><span class="com"># ..</span><span class="pln">
   </span><span class="kwd">end</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> </span><span class="typ">Trig</span><span class="pun">.</span><span class="pln">cos</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln">
   </span><span class="com"># ..</span><span class="pln">
   </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span></pre>
<p>We can define one more module with same function name but different functionality:</p>
<pre class="prettyprint notranslate prettyprinted"><span class="com">#!/usr/bin/ruby</span><span class="pln">

</span><span class="com"># Module defined in moral.rb file</span><span class="pln">

</span><span class="kwd">module</span><span class="pln"> </span><span class="typ">Moral</span><span class="pln">
   VERY_BAD </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
   BAD </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> </span><span class="typ">Moral</span><span class="pun">.</span><span class="pln">sin</span><span class="pun">(</span><span class="pln">badness</span><span class="pun">)</span><span class="pln">
   </span><span class="com"># ...</span><span class="pln">
   </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span></pre>
<p>Like class methods, whenever you define a method in a module, you specify the module name followed by a dot and then the method name.</p>
<h2>Ruby <i>require</i> Statement:</h2>
<p>The require statement is similar to the include statement of C and C++ and the import statement of Java. If a third program wants to use any defined module, it can simply load the module files using the Ruby <i>require</i> statement:</p>
<h2>Syntax:</h2>
<pre class="prettyprint notranslate prettyprinted"><span class="kwd">require</span><span class="pln"> filename</span></pre>
<p>Here, it is not required to give <b>.rb</b> extension along with a file name.</p>
<h2>Example:</h2>
<pre class="prettyprint notranslate prettyprinted"><span class="pln">$LOAD_PATH </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'.'</span><span class="pln">

</span><span class="kwd">require</span><span class="pln"> </span><span class="str">'trig.rb'</span><span class="pln">
</span><span class="kwd">require</span><span class="pln"> </span><span class="str">'moral'</span><span class="pln">

y </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Trig</span><span class="pun">.</span><span class="pln">sin</span><span class="pun">(</span><span class="typ">Trig</span><span class="pun">::</span><span class="pln">PI</span><span class="pun">/</span><span class="lit">4</span><span class="pun">)</span><span class="pln">
wrongdoing </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Moral</span><span class="pun">.</span><span class="pln">sin</span><span class="pun">(</span><span class="typ">Moral</span><span class="pun">::</span><span class="pln">VERY_BAD</span><span class="pun">)</span></pre>
<p>Here we are using <b>$LOAD_PATH &lt;&lt; '.'</b> to make Ruby aware that included files must be searched in the current directory. If you do not want to use $LOAD_PATH then you can use <b>require_relative</b> to include files from a relative directory.</p>
<p><b>IMPORTANT:</b> Here, both the files contain same function name. So, this will result in code ambiguity while including in calling program but modules avoid this code ambiguity and we are able to call appropriate function using module name.</p>
<h2>Ruby <i>include</i> Statement:</h2>
<p>You can embed a module in a class. To embed a module in a class, you use the <i>include</i> statement in the class:</p>
<h2>Syntax:</h2>
<pre class="prettyprint notranslate prettyprinted"><span class="pln">include modulename</span></pre>
<p>If a module is defined in a separate file, then it is required to include that file using <i>require</i> statement before embedding module in a class.</p>
<h2>Example:</h2>
<p>Consider following module written in <i>support.rb</i> file.</p>
<pre class="prettyprint notranslate prettyprinted"><span class="kwd">module</span><span class="pln"> </span><span class="typ">Week</span><span class="pln">
   FIRST_DAY </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Sunday"</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> </span><span class="typ">Week</span><span class="pun">.</span><span class="pln">weeks_in_month
      puts </span><span class="str">"You have four weeks in a month"</span><span class="pln">
   </span><span class="kwd">end</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> </span><span class="typ">Week</span><span class="pun">.</span><span class="pln">weeks_in_year
      puts </span><span class="str">"You have 52 weeks in a year"</span><span class="pln">
   </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span></pre>
<p>Now, you can include this module in a class as follows:</p>
<pre class="prettyprint notranslate tryit prettyprinted"><span class="com">#!/usr/bin/ruby</span><span class="pln">
$LOAD_PATH </span><span class="pun">&lt;&lt;</span><span class="pln"> </span><span class="str">'.'</span><span class="pln">
</span><span class="kwd">require</span><span class="pln"> </span><span class="str">"support"</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Decade</span><span class="pln">
include </span><span class="typ">Week</span><span class="pln">
   no_of_yrs</span><span class="pun">=</span><span class="lit">10</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> no_of_months
      puts </span><span class="typ">Week</span><span class="pun">::</span><span class="pln">FIRST_DAY
      number</span><span class="pun">=</span><span class="lit">10</span><span class="pun">*</span><span class="lit">12</span><span class="pln">
      puts number
   </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">
d1</span><span class="pun">=</span><span class="typ">Decade</span><span class="pun">.</span><span class="kwd">new</span><span class="pln">
puts </span><span class="typ">Week</span><span class="pun">::</span><span class="pln">FIRST_DAY
</span><span class="typ">Week</span><span class="pun">.</span><span class="pln">weeks_in_month
</span><span class="typ">Week</span><span class="pun">.</span><span class="pln">weeks_in_year
d1</span><span class="pun">.</span><span class="pln">no_of_months</span></pre>
<p>This will produce the following result:</p>
<pre class="prettyprint notranslate prettyprinted"><span class="typ">Sunday</span><span class="pln">
</span><span class="typ">You</span><span class="pln"> have four weeks </span><span class="kwd">in</span><span class="pln"> a month
</span><span class="typ">You</span><span class="pln"> have </span><span class="lit">52</span><span class="pln"> weeks </span><span class="kwd">in</span><span class="pln"> a year
</span><span class="typ">Sunday</span><span class="pln">
</span><span class="lit">120</span></pre>
<h2>Mixins in Ruby:</h2>
<p>Before going through this section, I assume you have knowledge of Object Oriented Concepts.</p>
<p>When a class can inherit features from more than one parent class, the class is supposed to show multiple inheritance.</p>
<p>Ruby does not support multiple inheritance directly but Ruby Modules have another wonderful use. At a stroke, they pretty much eliminate the need for multiple inheritance, providing a facility called a <i>mixin</i>.</p>
<p>Mixins give you a wonderfully controlled way of adding functionality to classes. However, their true power comes out when the code in the mixin starts to interact with code in the class that uses it.</p>
<p>Let us examine the following sample code to gain an understand of mixin:</p>
<pre class="prettyprint notranslate prettyprinted"><span class="kwd">module</span><span class="pln"> A
   </span><span class="kwd">def</span><span class="pln"> a1
   </span><span class="kwd">end</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> a2
   </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">module</span><span class="pln"> B
   </span><span class="kwd">def</span><span class="pln"> b1
   </span><span class="kwd">end</span><span class="pln">
   </span><span class="kwd">def</span><span class="pln"> b2
   </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Sample</span><span class="pln">
include A
include B
   </span><span class="kwd">def</span><span class="pln"> s1
   </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">

samp</span><span class="pun">=</span><span class="typ">Sample</span><span class="pun">.</span><span class="kwd">new</span><span class="pln">
samp</span><span class="pun">.</span><span class="pln">a1
samp</span><span class="pun">.</span><span class="pln">a2
samp</span><span class="pun">.</span><span class="pln">b1
samp</span><span class="pun">.</span><span class="pln">b2
samp</span><span class="pun">.</span><span class="pln">s1</span></pre>
<p>Module A consists of the methods a1 and a2. Module B consists of the methods b1 and b2. The class Sample includes both modules A and B. The class Sample can access all four methods, namely, a1, a2, b1, and b2. Therefore, you can see that the class Sample inherits from both the modules. Thus, you can say the class Sample shows multiple inheritance or a <i>mixin</i>.</p>
</div>
</ion-content>
</ion-view>